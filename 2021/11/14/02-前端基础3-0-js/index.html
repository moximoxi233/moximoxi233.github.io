<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JS," />










<meta name="description" content="2.3 JS2.3.1 js基础关键字 js关键字：js中有特定含义，不能作为变量名、函数名来使用，不然会在js载入过程中出现编译错误  不能将关键字、保留字、true、false、null作为标识符 数据类型 值类型：数字（number）、字符串（String）、布尔类型（Boolean）、空值（null）、未定义（undefined）、Symbol、BigInt 这7种基本类型（单类型）都可以">
<meta property="og:type" content="article">
<meta property="og:title" content="02 前端基础3.0-js">
<meta property="og:url" content="http://yoursite.com/2021/11/14/02-%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%803-0-js/index.html">
<meta property="og:site_name" content="MoxiMoxi">
<meta property="og:description" content="2.3 JS2.3.1 js基础关键字 js关键字：js中有特定含义，不能作为变量名、函数名来使用，不然会在js载入过程中出现编译错误  不能将关键字、保留字、true、false、null作为标识符 数据类型 值类型：数字（number）、字符串（String）、布尔类型（Boolean）、空值（null）、未定义（undefined）、Symbol、BigInt 这7种基本类型（单类型）都可以">
<meta property="og:locale">
<meta property="article:published_time" content="2021-11-14T13:25:04.000Z">
<meta property="article:modified_time" content="2021-11-14T13:27:25.552Z">
<meta property="article:author" content="moximoxi233">
<meta property="article:tag" content="JS">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/11/14/02-前端基础3-0-js/"/>





  <title>02 前端基础3.0-js | MoxiMoxi</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MoxiMoxi</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-learning">
          <a href="/learning/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            learning
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">

      <div class="main-inner">


        <div class="content-wrap">
        <a target="_blank" rel="noopener" href="https://github.com/moximoxi233" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>



          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/14/02-%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%803-0-js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MoxiMoxi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">02 前端基础3.0-js</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-14T21:25:04+08:00">
                2021-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="2-3-JS"><a href="#2-3-JS" class="headerlink" title="2.3 JS"></a>2.3 JS</h3><h3 id="2-3-1-js基础"><a href="#2-3-1-js基础" class="headerlink" title="2.3.1 js基础"></a>2.3.1 js基础</h3><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><blockquote>
<p>js关键字：js中有特定含义，不能作为变量名、函数名来使用，不然会在js载入过程中出现编译错误</p>
</blockquote>
<p>不能将关键字、保留字、true、false、null作为标识符</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul>
<li><p>值类型：数字（number）、字符串（String）、布尔类型（Boolean）、空值（null）、未定义（undefined）、Symbol、BigInt</p>
<p>这7种基本类型（单类型）都可以用typeof运算符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof &quot;xxx&quot;===&quot;string&quot;   //true</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="数值（number）"><a href="#数值（number）" class="headerlink" title="数值（number）"></a>数值（number）</h5><blockquote>
<p>不要用小数验证小数</p>
<p>不要用NaN判断是不是NaN（js规定NaN==NaN//false）</p>
<p>可以用isNaN判断该变量是否为数字</p>
</blockquote>
<h5 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h5><ol>
<li><p>toLowerCase()/toUpperCase() 将字符转为小/大写，返回新的字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;wanghhh&quot;</span>;</span><br><span class="line">str.toLowerCase(); <span class="comment">//&#x27;wanghhh&#x27;</span></span><br><span class="line">str.toUpperCase();  <span class="comment">//&#x27;WANGHHH&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>charAt()/indexOf()/lastIndexOf()  返回指定下标的字符/返回指定字符第一次出现的位置/返回指定字符最后出现的位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;xuexi&#x27;</span></span><br><span class="line">str.charAt(<span class="number">1</span>);  <span class="comment">//&#x27;u&#x27;</span></span><br><span class="line">str.charAt(<span class="number">10</span>);  <span class="comment">//&#x27;&#x27; 指定下标必须是有效位置，否则返回空字符</span></span><br><span class="line">str.charAt(-<span class="number">3</span>);  <span class="comment">//&#x27;&#x27;</span></span><br><span class="line">----</span><br><span class="line">str.indexOf(<span class="string">&#x27;x&#x27;</span>); <span class="comment">//0</span></span><br><span class="line">str.indexOf(<span class="string">&#x27;xi&#x27;</span>);  <span class="comment">//3</span></span><br><span class="line">str.indexOf(<span class="string">&#x27;xi&#x27;</span>,str.indexOf(<span class="string">&#x27;x&#x27;</span>)+<span class="number">1</span>); <span class="comment">//3 查找该字符第二次出现的位置，如果未找到指定的字符会返回-1</span></span><br><span class="line">----</span><br><span class="line">str.lastIndexOf(<span class="string">&#x27;x&#x27;</span>); <span class="comment">//3</span></span><br><span class="line">str.lastIndexOf(<span class="string">&#x27;ex&#x27;</span>);  <span class="comment">//2</span></span><br><span class="line">str.lastIndexOf(<span class="string">&#x27;x&#x27;</span>,str.lastIndexOf(<span class="string">&#x27;x&#x27;</span>)-<span class="number">1</span>);  <span class="comment">//0 返回指定字符倒数第二次出现的位置</span></span><br><span class="line">str.lastIndexOf(<span class="string">&#x27;e&#x27;</span>,str.lastIndexOf(<span class="string">&#x27;e&#x27;</span>)-<span class="number">1</span>);  <span class="comment">//-1 如果未找到指定的字符会返回-1</span></span><br></pre></td></tr></table></figure></li>
<li><p>slice(开始位置，结束位置「选填」) /substring() 根据指定位置提取字符串，两个方法使用类似，但是第二个方法不能提取下标为负数的字符片段</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">str.slice(<span class="number">1</span>);  <span class="comment">//&#x27;ello world&#x27; 只写开始位置，默认截取从开始位置之后且包含开始字符的字符片段</span></span><br><span class="line">str.slice(<span class="number">1</span>,<span class="number">3</span>);  <span class="comment">//&#x27;el&#x27;  截取开始位置到结束位置但不包含结束位置的的字符片段</span></span><br><span class="line">str.slice(-<span class="number">3</span>,-<span class="number">1</span>);  <span class="comment">//&#x27;rl&#x27;  -1位置是倒数第一个字符，-3位置是倒数第三个字符</span></span><br><span class="line">str.slice(str.length);  <span class="comment">//&#x27;&#x27;   如果指定位置在该字符串中无效，则返回空字符串 </span></span><br></pre></td></tr></table></figure></li>
<li><p>substr(开始位置，截取字符片段长度) 返回指定下标开始指定长度的字符片段</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str.substr(<span class="number">1</span>,<span class="number">3</span>);  <span class="comment">//&#x27;ell&#x27;</span></span><br><span class="line">str.substr(<span class="number">1</span>);  <span class="comment">//&#x27;ello world&#x27;  未指定长度默认截取开始下标至结尾处的所有字符</span></span><br><span class="line">str.substr(-<span class="number">2</span>,<span class="number">2</span>); <span class="comment">//&#x27;ld&#x27; -1位置是倒数第一个字符，-2位置是倒数第二个字符</span></span><br></pre></td></tr></table></figure></li>
<li><p>split() 把字符串按照一定规则分割成数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str.split();  <span class="comment">//[&#x27;hello world&#x27;]</span></span><br><span class="line">str.split(<span class="string">&#x27;&#x27;</span>); <span class="comment">//[&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;] 将每个字符分割并存入数组中</span></span><br><span class="line">str.split(<span class="string">&#x27;o&#x27;</span>); [<span class="string">&#x27;hell&#x27;</span>, <span class="string">&#x27; w&#x27;</span>, <span class="string">&#x27;rld&#x27;</span>]</span><br><span class="line">str.split(<span class="string">&#x27; &#x27;</span>); <span class="comment">//[&#x27;hello&#x27;, &#x27;world&#x27;]  以指定字符为间隔，将字符串分割并存入数组中</span></span><br><span class="line">str.split(<span class="string">&#x27; &#x27;</span>,<span class="number">1</span>);  <span class="comment">//[&#x27;hello&#x27;] 将字符串分割，并控制数组的长度</span></span><br></pre></td></tr></table></figure></li>
<li><p>replace(指定字符,新字符) 将字符串中的指定的字符替换成新字符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str.replace(<span class="string">&quot;h&quot;</span>,<span class="string">&quot;H&quot;</span>);  <span class="comment">//&#x27;Hello world&#x27;</span></span><br><span class="line">str.replace(<span class="regexp">/o/</span>,<span class="string">&quot;H&quot;</span>);  <span class="comment">//&#x27;hellH world&#x27;</span></span><br><span class="line">str.replace(<span class="regexp">/o/ig</span>,<span class="string">&quot;H&quot;</span>); <span class="comment">//&#x27;hellH wHrld&#x27; 替换与正则表达式匹配的字符串</span></span><br></pre></td></tr></table></figure></li>
<li><p>match()  返回所有查找关键字内容的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.match(<span class="regexp">/o/ig</span>);  <span class="comment">//[&#x27;o&#x27;, &#x27;o&#x27;]</span></span><br><span class="line">str.match(<span class="string">&#x27;l&#x27;</span>);  <span class="comment">//[&#x27;l&#x27;, index: 2, input: &#x27;hello world&#x27;, groups: undefined]</span></span><br></pre></td></tr></table></figure></li>
<li><p>contact() 将两个字符串连接并返回一个新字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1=<span class="string">&#x27;hello&#x27;</span>;<span class="keyword">var</span> str2=<span class="string">&#x27;world&#x27;</span>;str1.concat(str2,<span class="string">&#x27;hhh&#x27;</span>);  <span class="comment">//&#x27;helloworldhhh&#x27; 跟用+连接一样</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="布尔类型（Boolean）"><a href="#布尔类型（Boolean）" class="headerlink" title="布尔类型（Boolean）"></a>布尔类型（Boolean）</h5><ol>
<li><p>true/false 不一定等于1/0，要通过Number()转换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boolean=<span class="literal">true</span>;boolean===<span class="number">1</span> <span class="comment">//falseNumber(boolean)===1  //true</span></span><br></pre></td></tr></table></figure></li>
<li><p>各数据类型转换为布尔类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27; &#x27;</span>)  <span class="comment">//trueBoolean(89) //trueBoolean(0);  //false 1/0比较特殊Boolean(undefined); //falseBoolean(NaN);  //falseBoolean(null); //falseBoolean([]); //trueBoolean(false);  //falseBoolean(true);  //true</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="空值（null）"><a href="#空值（null）" class="headerlink" title="空值（null）"></a>空值（null）</h5><p>表示一个空指针对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(<span class="literal">null</span>); <span class="comment">//&#x27;object&#x27;typeof([]);  //&#x27;object&#x27;   typeof无法精确检验出数组</span></span><br></pre></td></tr></table></figure>

<p>*没有必要将一个变量初始化为undefined，但在保存对象的变量时</p>
<h5 id="undefined（未定义）"><a href="#undefined（未定义）" class="headerlink" title="undefined（未定义）"></a>undefined（未定义）</h5><p>对未初始化和未声明的变量执行typeof操作符都会返回undefined应当初始化为null值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;<span class="built_in">console</span>.log(a); <span class="comment">//undefined 未定义console.log(cc); //error：cc is not definedtypeof(a); //&#x27;undefined&#x27;typeof(cc); //&#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="Symbol-未完"><a href="#Symbol-未完" class="headerlink" title="Symbol-未完"></a>Symbol-未完</h5><h5 id="BigInt-未完"><a href="#BigInt-未完" class="headerlink" title="BigInt-未完"></a>BigInt-未完</h5><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>Object，包含function、Array、Date、Map、Set</p>
<p>部分Object派生出来的数据类型可以使用instanceof关键字检验(instanceof运算符用来检测 constructor。prototype 是否存在于参数 object的原型链上)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];b <span class="keyword">instanceof</span> <span class="built_in">Array</span>；<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h5 id="Array（数组）"><a href="#Array（数组）" class="headerlink" title="Array（数组）"></a>Array（数组）</h5><ol>
<li><p>unshift()/push() 将数组开头/尾部添加1个或多个元素，并返回数组长度。<strong>原数组改变</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1  <span class="comment">//(5) [1, 2, 3, 11, 9]arr1.unshift(0,10);  //7arr1  //(7) [0, 10, 1, 2, 3, 11, 9]----var arr1=[1,2,3]arr1.push(11,9,10); //arr1 //[1, 2, 3, 11, 9, 10]</span></span><br></pre></td></tr></table></figure></li>
<li><p>shift()/pop() 删除并返回数组的第一个/最后一个元素，如果数组为空则返回undefined。<strong>原数组改变</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1  <span class="comment">//(7) [0, 10, 1, 2, 3, 11, 9]arr1.shift()  //0arr1  //(6) [10, 1, 2, 3, 11, 9]----arr1  //(6) [1, 2, 3, 11, 9, 10]arr1.pop()  //10arr1  //(5) [1, 2, 3, 11, 9][].pop() //undefined</span></span><br></pre></td></tr></table></figure></li>
<li><p>concat(数组1，数组2…)合并多个数组并返回一个合并后的数组。原数组不变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];<span class="keyword">var</span> arr2=[<span class="number">0</span>,<span class="number">0</span>];arr1.concat(arr2,[<span class="number">1</span>])  <span class="comment">//(6) [1, 2, 3, 0, 0, 1]</span></span><br></pre></td></tr></table></figure></li>
<li><p>Join() 将数组通过指定字符串联在一起并将这串字符返回，默认用逗号串联。不会改变原数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1;<span class="comment">//(3) [1, 2, 3]arr1.join()//&#x27;1,2,3&#x27;arr1.join(&#x27;-&#x27;)//&#x27;1-2-3&#x27;arr1//(3) [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li>
<li><p>reverse() 将原数组倒序，并返回新的数组。<strong>原数组改变</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1 <span class="comment">//(3) [1, 2, 3]arr1.reverse()？/(3) [3, 2, 1]arr1 //(3) [3, 2, 1]</span></span><br></pre></td></tr></table></figure></li>
<li><p>sort() 将数组元素进行排序（按照字符串UniCode码排序），默认从小到大排序，也可以添加回调函数更改排序规则。<strong>原数组改变</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1 <span class="comment">//(3) [3, 2, 1]arr1.sort() //(3) [1, 2, 3]arr1.sort((a,b)=&gt;&#123;return b-a&#125;) //(3) [3, 2, 1]arr1  //(3) [3, 2, 1]</span></span><br></pre></td></tr></table></figure></li>
<li><p>map(function) 原数组的每一项执行函数后返回一个新数组。原数组不变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1 <span class="comment">//(3) [3, 2, 1]arr1.map((item)=&gt;&#123;return item+=1&#125;) //(3) [4, 3, 2]arr1 //(3) [3, 2, 1]</span></span><br></pre></td></tr></table></figure></li>
<li><p>slice(开始位置，结束位置) 从指定开始位置到结束位置但不包含结束位置的元素截取数组，原数组不变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1 <span class="comment">//(3) [3, 2, 1]arr1.slice(1,2)  //[2]arr1.slice(-2,-1) //[2]  -1表示数组最后位置，-2表示倒数第二个arr1 //(3) [3, 2, 1]</span></span><br></pre></td></tr></table></figure></li>
<li><p>splice(开始位置,删除的元素个数,添加的元素..) 删除元素并添加元素返回删除的元素。<strong>原数组改变</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1; <span class="comment">//(3) [3, 2, 1]arr1.slice(-2,-1) //[2]arr1.splice(1,1,0) //[2]arr1; //(3) [3, 0, 1]arr1.splice(1,0,111) //[] 当“删除的元素个数”为0时表示不删除元素仅添加元素arr1 //(4) [3, 111, 0, 1]</span></span><br></pre></td></tr></table></figure></li>
<li><p>forEach(function) 用于调用数组每个元素并将元素传递给回调函数，无返回值。数组不改变</p>
</li>
</ol>
<p>   *注意forEach()与map()的区别</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1 <span class="comment">//(4) [3, 111, 0, 1]   arr1.forEach((item)=&gt;&#123;sum+=item&#125;) //undefined   sum //155   arr1 //(4) [3, 111, 0, 1]   -----   arr1 //(4) [3, 111, 0, 1]   var sum2=0;   arr1.map((item)=&gt;&#123;return sum2+=item&#125;) //(4) [3, 114, 114, 115]   //*map()会返回一个数组</span></span><br></pre></td></tr></table></figure>

<ol start="11">
<li><p>every(function) 对数组每一项元素进行判断，如果都符合条件则返回true，否则返回false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1 <span class="comment">//(4) [3, 111, 0, 1]arr1.every((item)=&gt;&#123;return item&gt;=0&#125;) //true</span></span><br></pre></td></tr></table></figure></li>
<li><p>some(function) 对数组每一项元素进行判断，如果都不符合条件则返回false，否则返回true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1 <span class="comment">//(4) [3, 111, 0, 1]arr1.some(item=&gt;&#123;return item%2==0&#125;)//true</span></span><br></pre></td></tr></table></figure></li>
<li><p>Array.reduce(function)，reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1 <span class="comment">//(4) [3, 111, 0, 1]arr1.reduce((item1,item2)=&gt;item1+item2) //115arr1.reduce((item1,item2)=&gt;item1-item2) //-109arr1 //(4) [3, 111, 0, 1]</span></span><br></pre></td></tr></table></figure>

<p>*注意：<br>改变数组的函数有：unshift()/push()添加元素、shift()/pop()删除元素、splice()删除并添加元素、reverse()数组倒序、sort()数组排序</p>
</li>
</ol>
<h5 id="Set-对象"><a href="#Set-对象" class="headerlink" title="Set 对象"></a>Set 对象</h5><p>ES6提供了新的数据结构，Set类似于数组，但是成员的值都是唯一的，没有重复的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> set=<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>])set.size <span class="comment">//4set  //Set(4) &#123;1, 2, 3, 4&#125;set.add(NaN); //Set(5) &#123;1, 2, 3, 4, NaN&#125;set.add(NaN); //Set(5) &#123;1, 2, 3, 4, NaN&#125; Set结构下NaN等于自身，不允许重复出现console.log(set.has(NaN)); //trueset.add(&#123;&#125;); //Set(6) &#123;1, 2, 3, 4, NaN, …&#125;set.add(&#123;&#125;); //Set(7) &#123;1, 2, 3, 4, NaN, …&#125; //而两个对象是不相等的，他们指向的区域是不一样的</span></span><br></pre></td></tr></table></figure>

<p>利用Set特性，实现数组去重</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>];arr=<span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));arr <span class="comment">//(6) [1, 2, 3, 5, 6, 4]</span></span><br></pre></td></tr></table></figure>

<p>*Set结构 键名=键值,Set页有forEach()、map()、filter()方法…</p>
<h5 id="Map对象"><a href="#Map对象" class="headerlink" title="Map对象"></a>Map对象</h5><p>键值对结构，一个key只能对应一个value</p>
<p>初始化map对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1let m1=new Map();m1.set(&quot;小li&quot;,24);m1.set(&quot;小张&quot;,22)m1.set(&quot;小chen&quot;,22) m1 //Map(3) &#123;&#x27;小li&#x27; =&gt; 24, &#x27;小张&#x27; =&gt; 22, &#x27;小chen&#x27; =&gt; 22&#125;//2let m2=new Map().set(&quot;xiao&quot;,19).set(&quot;xi&quot;,22);m2 //Map(2) &#123;&#x27;xiao&#x27; =&gt; 19, &#x27;xi&#x27; =&gt; 22&#125;//3let m3=new Map([[&quot;a&quot;,1],[&quot;b&quot;,2]])m3 //Map(2) &#123;&#x27;a&#x27; =&gt; 1, &#x27;b&#x27; =&gt; 2&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="作用域-amp-作用域链"><a href="#作用域-amp-作用域链" class="headerlink" title="作用域&amp;作用域链"></a>作用域&amp;作用域链</h4><p>作用域：某些特定变量、函数和对象的可访问范围，作用域又分<strong>全局作用域</strong>和<strong>函数作用域</strong></p>
<ul>
<li><p>程序在编译时，会将变量定义在所在的作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;<span class="comment">//全局变量---&gt;全局作用域function fn()&#123;var b=2 //局部变量---&gt;函数作用域c=3 //全局变量---&gt;全局作用域&#125;console.log(b);//ReferenceError: b is not definedconsole.log(a);//1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>作用域链：使用变量时会优先在当前作用域查找，如果没查到就会向上级作用域查找，直到查到全局作用域，这个查找过程形成的链条就叫做<strong>作用域链</strong></p>
<ul>
<li><p>使用变量时会从当前作用域向上查找变量（向上查找）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;<span class="comment">//全局作用域    function fn1()&#123;//fn1作用域        var a=3;        (function fn2()&#123;//fn2作用域            var b=9;            console.log(++a);        &#125;)()    &#125;    fn1();//4</span></span><br></pre></td></tr></table></figure>

<p>注：fn1作用域就是fn2作用域的上级</p>
</li>
<li><p>子函数被外部使用父级环境将被保留</p>
</li>
</ul>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><ul>
<li><p>算数运算符</p>
<p>+、-、/、%、*</p>
</li>
<li><p>一元运算符</p>
<p>只有操作数的运算符，**++自加1<strong>，</strong>–自减1**</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;a++ <span class="comment">//1a //2var b=1++b //2b //2-----var a = 1; var b = ++a + ++a; console.log(b);  //5var a = 1; var b = a++ + ++a; console.log(b);   //4 var a = 1; var b = a++ + a++; console.log(b);    //3var a = 1; var b = ++a + a++; console.log(b);  //4</span></span><br></pre></td></tr></table></figure></li>
<li><p>逻辑运算符（布尔运算符）</p>
<p>&amp;&amp;（与）、||（或）、！（非）</p>
<p>​    <strong>||</strong></p>
<ul>
<li><p>只要“||”前面为false，无论“||”后面是true还是false，结果都返回“||”后面的值。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>||<span class="number">2</span>  <span class="comment">//2</span></span><br></pre></td></tr></table></figure></li>
<li><p>只要“||”前面为true，无论“||”后面是true还是false，结果都返回“||”前面的值。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>||<span class="number">0</span>  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p><strong>&amp;&amp;</strong></p>
</li>
<li><p>只要“&amp;&amp;”前面是false，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”前面的值; </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>&amp;&amp;<span class="number">2</span> <span class="comment">//0</span></span><br></pre></td></tr></table></figure></li>
<li><p>只要“&amp;&amp;”前面是true，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”后面的值;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>&amp;&amp;<span class="number">0</span>  <span class="comment">//0</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>关系运算符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; 	&gt; 	&gt;= 	&lt;= 	== 	!==	只比较值	===		!=== 比较值和数据类型</span><br></pre></td></tr></table></figure></li>
<li><p>赋值运算符<br>+=、-=、*=、/=、%=</p>
</li>
<li><p>运算符的优先级</p>
<ol>
<li>（）优先级最高</li>
<li>一元运算符（自加1，自减1）</li>
<li>算术运算符（* / + -）</li>
<li>关系运算符（&gt;       &gt;=     &lt;      &lt;=）</li>
<li>相等运算符（==    ！=     = = =     ！= = ）</li>
<li>逻辑运算符（先&amp;&amp; 后||）</li>
<li>赋值运算符</li>
</ol>
</li>
</ul>
<h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><h5 id="if…else-语句"><a href="#if…else-语句" class="headerlink" title="if…else 语句"></a>if…else 语句</h5><h5 id="swich-语句"><a href="#swich-语句" class="headerlink" title="swich 语句"></a>swich 语句</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//switch(表达式)&#123;    //     case 值1:代码1;    //     break;    //     case 值2:代码2;    //     break;    //     case 值3:代码3;    //     break;    //     default:代码5;	//	   break;    // &#125;	 	//语法：获取表达式的值，与值1比较如果值相等，执行代码1，跳出整个语句...var a=4;    switch (--a) &#123;    case 1:console.log(&quot;等于1&quot;);    break;    case 2:console.log(&quot;等于2&quot;);    break;    case 3:console.log(&quot;等于3&quot;);    break;    console.log(&quot;未找到&quot;);    &#125;//等于3</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>default后面的break，default可以省略</li>
<li>表达式的值和case语句中的值比较的是严格模式（===）</li>
<li>如果case语句后面的代码和break省略，代码可以正常执行，但是不会跳出整个语句而是继续往下执行</li>
</ul>
<h5 id="break，continue关键字"><a href="#break，continue关键字" class="headerlink" title="break，continue关键字"></a>break，continue关键字</h5><blockquote>
<p>break：循环语句中遇到 break 则立即跳出当前整个循环。</p>
<p>continue：跳出当前这一次循环，继续当前循环的下一个循环。</p>
</blockquote>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><blockquote>
<p><strong>循环结构步骤</strong></p>
<ol>
<li><p>声明循环变量</p>
</li>
<li><p>判断循环条件</p>
</li>
<li><p>执行循环体操作</p>
</li>
<li><p>更新循环变量</p>
<p>然后循环执行2-4，直到条件不成立，跳出循环</p>
</li>
</ol>
</blockquote>
<h5 id="while-先判断后执行"><a href="#while-先判断后执行" class="headerlink" title="while 先判断后执行"></a>while 先判断后执行</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">5</span>,<span class="comment">//第1步：声明循环变量    sum=0;while(num&gt;=0)&#123;//第2步：判断循环条件sum+=num;// 第3步：执行循环体操作num--;&#125;//第4步：更新循环变量sum //15-----</span></span><br></pre></td></tr></table></figure>

<h5 id="do…while-先执行再判断"><a href="#do…while-先执行再判断" class="headerlink" title="do…while 先执行再判断"></a>do…while 先执行再判断</h5><p>至少执行一次循环体操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1=<span class="number">10</span>;<span class="keyword">while</span>(n1&lt;<span class="number">10</span>)&#123;n1++;&#125;n1 <span class="comment">//10-----var n2=10;do&#123;n2++&#125;while(n2&lt;10);n2 //11</span></span><br></pre></td></tr></table></figure>

<h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>跟while类似，都是先判断再执行for循环三个表达式都可以省略，但是两个“;”缺一不可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum=0<span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i=<span class="number">5</span>;i&gt;<span class="number">0</span>;i--</span>)</span>&#123;sum+=i&#125;sum  <span class="comment">//15</span></span><br></pre></td></tr></table></figure>

<h5 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in循环</h5><p>主要用来遍历对象<br>for(keys in obj) keys表示每个键值对的键</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;<span class="built_in">this</span>.name=<span class="string">&quot;xiaoli&quot;</span>;<span class="built_in">this</span>.age=<span class="number">24</span>;<span class="built_in">this</span>.fn=<span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;年龄：&quot;</span>+age)&#125;&#125;<span class="keyword">var</span> p1=<span class="keyword">new</span> Person();<span class="keyword">for</span>(keys <span class="keyword">in</span> p1)&#123;<span class="built_in">console</span>.log(p1[keys])&#125;<span class="comment">// xiaoli// 24// ƒ (name,age)&#123;//console.log(&quot;姓名：&quot;+name+&quot;年龄：&quot;+age)//&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for-of循环"></a>for-of循环</h5><p>便利所有数据结构的统一方法</p>
<blockquote>
<p>一个数据结构只要部署了Symbol.iterator属性，就被当作具有iterator接口，就可以使用for…of 循环遍历它的成员</p>
<p>for…of 可以使用的范围包括：字符串、数组、Set、Map以及一些类似数组的对象（argument对象、DOM NodeList对象）、Generator对象</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历字符串var str=&quot;hello&quot;;for(let a of str)&#123;console.log(a)&#125; //h e l l o//遍历数组var arr=[1,2,3,4]for(let a of arr)&#123;console.log(a)&#125; //1 2 3 4//遍历对象function Person()&#123;this.name=&quot;xiaoli&quot;;this.age=24;this.fn=function(name,age)&#123;console.log(&quot;姓名：&quot;+name+&quot;年龄：&quot;+age)&#125;&#125;var p1=new Person();//遍历Set结构var set=new Set([&quot;hello&quot;,&quot;world&quot;])for(let a of set)&#123;console.log(a)&#125;//hello world//遍历Map结构var map=new Map()map.set(&quot;aaa&quot;,111);map.set(&quot;bbb&quot;,222);for(let [name,val] of map)&#123;console.log(name+&quot;:&quot;+val)&#125; //aaa:111   bbb:222</span></span><br></pre></td></tr></table></figure>

<h5 id="for…in-和-for…of-比较"><a href="#for…in-和-for…of-比较" class="headerlink" title="for…in 和 for…of 比较"></a>for…in 和 for…of 比较</h5><ul>
<li><p>for..in</p>
<p>循环读取键名，不仅遍历手动添加的其他键，甚至会遍历原型链上的键。（数组的键名是数字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">//原型链上的键Array.prototype.arrCustom = function () &#123;&#125;;//原型链上的键let iterable = [3, 5, 7];iterable.foo = &quot;hello&quot;;//手动添加的键for (let i in iterable) &#123;  console.log(i); &#125;//  0, 1, 2, &quot;foo&quot;, &quot;arrCustom&quot;, &quot;objCustom&quot;</span></span><br></pre></td></tr></table></figure>

<p>*for…in 遍历key 主要用来遍历对象，不适合遍历数组</p>
</li>
<li><p>for…of</p>
<p>提供了遍历所有数据结构的统一操作接口，用来遍历value</p>
</li>
</ul>
<h3 id="2-3-2-函数"><a href="#2-3-2-函数" class="headerlink" title="2.3.2 函数"></a>2.3.2 函数</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn);<span class="comment">//ƒ fn()&#123;        //console.log(&quot;hhhh&quot;)    //&#125;fn();//hhhhfunction fn()&#123;        console.log(&quot;hhhh&quot;)    &#125;</span></span><br></pre></td></tr></table></figure>

<p>通过函数声明的函数存在变量提升</p>
<h4 id="函数表达式-匿名函数"><a href="#函数表达式-匿名函数" class="headerlink" title="函数表达式(匿名函数)"></a>函数表达式(匿名函数)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn);<span class="comment">//undefined	fn();//Uncaught TypeError: fn is not a function    var fn=function()&#123;        console.log(&quot;hhhh&quot;)    &#125;</span></span><br></pre></td></tr></table></figure>

<p>以上函数是一个匿名函数，函数存储在变量中，可以通过变量名来调用，不存在变量提升</p>
<h4 id="Function-构造器"><a href="#Function-构造器" class="headerlink" title="Function() 构造器"></a>Function() 构造器</h4><blockquote>
<p>函数是对象，那就可以使用函数的动态特性。<br>函数是对象，就有构造函数创建函数。<br>函数是函数，可以创建其他对象<br>函数是唯一可以限定作用域的结果</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Function的参数全是字符串，其作用就是将参数连接成一个函数如果参数只有一个即表示函数体如果参数有多个，最后一个参数表示函数体，其他几个参数均表示函数参数如果没有函数即创建空函数*/</span><span class="keyword">var</span> fn1=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;console.log(&quot;hhhh&quot;)&#x27;</span>)fn1();<span class="comment">// hhhhvar fn2=new Function(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;console.log(a+b)&#x27;)fn2(4,6) //10</span></span><br></pre></td></tr></table></figure>

<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//函数体&#125;)()//函数自调用</span></span><br></pre></td></tr></table></figure>

<p>一般函数是通过其变量名调用，匿名函数没有变量接收就没办法通过变量名调用，但是可以通过自调用的形式调用函数，这种使用常用于一次性使用的函数。</p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><blockquote>
<p>箭头函数时函数声明的简写，在使用递归调用、构造函数、事件处理器时不建议使用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：/*有参数时：(arguments)=&gt;&#123;函数声明&#125;，只有一个参数时可以省略括号无参数时：()=&gt;&#123;&#125;*/var sum=(a,b)=&gt;a+b;//单一表达式不需要return返回，系统自动返回表达式计算结果sum(3,4) //7</span></span><br></pre></td></tr></table></figure>

<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><blockquote>
<p>形参：函数声明时设置的参数。</p>
<p>实参：函数调用时传递的参数</p>
</blockquote>
<ul>
<li><p>形参个数&gt;实参个数 时，没有传参的形参值为undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">x,y,z</span>)</span>&#123;<span class="built_in">console</span>.log(x,y,z)&#125;fn1(<span class="string">&quot;我&quot;</span>,<span class="string">&quot;来&quot;</span>) <span class="comment">//我 来 undefined</span></span><br></pre></td></tr></table></figure></li>
<li><p>形参个数&lt;实参个数 时，多余参数忽略不计</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn1(<span class="string">&quot;我&quot;</span>,<span class="string">&quot;来&quot;</span>,<span class="string">&quot;了&quot;</span>,<span class="string">&quot;hhhh&quot;</span>) <span class="comment">//我 来 了</span></span><br></pre></td></tr></table></figure></li>
<li><p>默认参数的使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一function fn2(total,year)&#123;year=year||12;console.log(`平均每月有：$&#123;total/year&#125;`);&#125;fn2(50000)  //平均每月有：4166.666666666667fn2(60000,10)  //平均每月有：6000//方式二function fn3(total,year=12)&#123;console.log(`平均每月有：$&#123;total/year&#125;`);&#125;fn3(50000) //平均每月有：4166.666666666667fn3(60000,10)  //平均每月有：6000</span></span><br></pre></td></tr></table></figure></li>
<li><p>函数可以作为参数传递</p>
</li>
<li><p>arguments </p>
<blockquote>
<p>arguments：函数获取参数的集合</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> [...arguments].reduce(<span class="function">(<span class="params">item1,item2</span>)=&gt;</span>&#123;<span class="keyword">return</span> item1+item2&#125;)&#125;sum(<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>);<span class="comment">//23</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="函数调用-amp-this"><a href="#函数调用-amp-this" class="headerlink" title="函数调用&amp;this"></a>函数调用&amp;this</h4><blockquote>
</blockquote>
<ul>
<li><p>作为一个函数直接被调用：<strong>fn()</strong><br>this指向window/undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非严格模式中 函数上下文this指向全局windowfunction fn()&#123;console.log(this);&#125;fn() //Window &#123;…&#125;//严格模式中，this指向undefiendfunction fn1()&#123;&quot;use strict&quot;;console.log(this);&#125;fn1()//undefined</span></span><br></pre></td></tr></table></figure></li>
<li><p>作为一个对象的方法调用：<strong>obj.fn()</strong><br>this指向这个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu1=&#123;<span class="attr">name</span>:<span class="string">&quot;zhangsan&quot;</span>,<span class="function"><span class="title">findthis</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>.name);<span class="built_in">console</span>.log(<span class="built_in">this</span>)&#125;&#125;stu1.findthis();  <span class="comment">//zhangsan  &#123;name: &#x27;zhangsan&#x27;, findthis: ƒ&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>作为构造函数时调用通过new fn()实例化一个新对象,此时的this指向的是当前实力化的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stu</span>(<span class="params">name</span>)</span>&#123; <span class="built_in">this</span>.name=name; <span class="built_in">this</span>.study=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>.name);<span class="built_in">console</span>.log(<span class="built_in">this</span>)&#125;&#125;<span class="keyword">var</span> stu1=<span class="keyword">new</span> Stu(<span class="string">&quot;xiaohong&quot;</span>);stu1.study() <span class="comment">//xiaohong//&#123;name: &#x27;xiaohong&#x27;, study: ƒ&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>箭头函数与它的外层函数指向同一个this</p>
</li>
<li><p>通过函数的apply()或call()调用，fn.apply() fn.call()</p>
<blockquote>
<p>改变this指向</p>
<p>call，apply第一个参数时函数上下文this<br>call 直接列出要传递的参数<br>appply 用数组传入要传递的参数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msg</span>(<span class="params">age</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.n&#125;</span>的年龄是<span class="subst">$&#123;age&#125;</span>`</span>);<span class="built_in">console</span>.log(<span class="built_in">this</span>);&#125;msg(<span class="number">22</span>) <span class="comment">//undefined的年龄是22  Window &#123;…&#125;msg.call(&#123;n:&quot;小红&quot;&#125;,23) //小红的年龄是23 &#123;n: &#x27;小红&#x27;&#125;msg.apply(&#123;n:&quot;小wang&quot;&#125;,[24]) //小wang的年龄是24 &#123;n: &#x27;小wang&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><ul>
<li>根据<strong>作用域链</strong>可知，使用变量时会向上查找，直到找到全局window</li>
<li>为了不占内存？函数被执行后其环境变量将在内存中删除，等函数再次被调用会重新创建新作用域。</li>
<li>如果子函数被使用时父级环境将被保留</li>
</ul>
<hr>
<p>由于不同函数作用域下的变量不能相互访问（不存在上下级关系时），<strong>js闭包</strong>：通过在一个函数内部创建另一个函数来实现不同函数下的变量相互访问。</p>
<p>闭包3大特性</p>
<ol>
<li><p>函数嵌套函数</p>
</li>
<li><p>函数内部可以引用函数外部的参数和变量</p>
</li>
<li><p>参数和变量不会被垃圾回收机制回收</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">fn1</span>(<span class="params">x</span>)</span>&#123;        <span class="keyword">var</span> a=<span class="number">1</span>;        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;            <span class="keyword">var</span> b=<span class="number">1</span>;            <span class="built_in">console</span>.log(++a,++x,++b);        &#125;    &#125;    <span class="keyword">var</span> fn2=fn1(<span class="number">1</span>);    fn2();<span class="comment">//2,2,2    fn2();//3,3,2    fn2();//4,4,2</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="沙箱-未完"><a href="#沙箱-未完" class="headerlink" title="沙箱-未完"></a>沙箱-未完</h4><blockquote>
<p>沙箱：将程序封闭在一个隔离的环境下执行，不会对外界的 程序造成干扰</p>
</blockquote>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h3 id="2-3-3-对象"><a href="#2-3-3-对象" class="headerlink" title="2.3.3 对象"></a>2.3.3 对象</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote>
<p>对象是无序属性的集合（其属性可以包括基本值、对象、函数</p>
<p>JS中对象是一个以键值对形式存储的属性的一个集合</p>
</blockquote>
<ul>
<li><p>对象创建与对象属性获取</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建var obj=&#123;name:&quot;xiaowang&quot;,sayhi:function()&#123;console.log(`hi,我是$&#123;this.name&#125;`)&#125;&#125;//获取值 1obj.name //&#x27;xiaowang&#x27;//获取值 2（主要用于通过变量定义属性的场景）obj[&quot;name&quot;]  //&#x27;xiaowang&#x27;obj[&quot;age&quot;]=18  //console.log(obj.age)  //18</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="对象常用操作"><a href="#对象常用操作" class="headerlink" title="对象常用操作"></a>对象常用操作</h4><ul>
<li><p>对象的属性和方法的添加/删除</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj.age  <span class="comment">//trueconsole.log(obj.age)  //undefineddelete obj.sayhi  //trueobj //&#123;name: &#x27;xiaowang&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>assign（对象1，对象2，对象3...）</code> 将对象1、2、3的属性复制到对象1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//assignvar obj=&#123;name:&quot;小红&quot;,age:18&#125;Object.assign(obj,&#123;name:&quot;校长&quot;&#125;,&#123;hair:&quot;black&quot;&#125;)//&#123;name: &#x27;校长&#x27;, age: 18, hair: &#x27;black&#x27;&#125; 如果有相同属性则会覆盖原对象属性</span></span><br></pre></td></tr></table></figure></li>
<li><p>检测属性</p>
<p><code>hasOwnProperty</code> 检测<strong>对象自身</strong>是否包含指定属性，不检查原型链上继承的属性</p>
<p><code>in</code> 可以在<strong>原型对象</strong>上检测</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">name</span>:<span class="string">&quot;小红&quot;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;obj.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>) <span class="comment">//trueobj.hasOwnProperty(&#x27;hasOwnProperty&#x27;) //false&#x27;hasOwnProperty&#x27; in obj //true</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取属性名 </p>
<p><code>getOwnPropertyNames</code> 可以获取对象的属性名集合，返回的是一个数组</p>
<p><code>keys</code> 获取对象的属性名</p>
<p><code>values</code> 获取对象的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)  <span class="comment">//[&#x27;name&#x27;, &#x27;age&#x27;]Object.keys(obj) //[&#x27;name&#x27;, &#x27;age&#x27;, &#x27;hair&#x27;]Object.values(obj) // [&#x27;校长&#x27;, 18, &#x27;black&#x27;]</span></span><br></pre></td></tr></table></figure></li>
<li><p>遍历对象</p>
<ul>
<li><p>for/in 可以遍历对象，操作对象的key，并且在遍历时会遍历原型上的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;<span class="built_in">console</span>.log(key,obj[key])&#125;<span class="comment">// name 校长// age 18// hair black</span></span><br></pre></td></tr></table></figure></li>
<li><p>for/of 不能直接遍历对象，用来遍历迭代对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj))&#123;<span class="built_in">console</span>.log(key,obj[key])&#125;<span class="comment">// name 校长// age 18// hair blackfor(var key of Object.entries(obj))&#123;//---entriesconsole.log(key)&#125;// [&#x27;name&#x27;, &#x27;校长&#x27;]// [&#x27;age&#x27;, 18]// [&#x27;hair&#x27;, &#x27;black&#x27;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>对象拷贝</p>
<blockquote>
<p>对象和函数、数组一样，都是引用类型，复制只会复制其引用地址</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2=objobj2.name=<span class="string">&quot;obj2&quot;</span>;<span class="comment">//&#x27;obj2&#x27;obj.name  //&#x27;obj2&#x27;//指向同一块内存地址obj===obj2 //true</span></span><br></pre></td></tr></table></figure></li>
<li><p>this</p>
<blockquote>
<p>对象的this始终指向当前对象，在对象的的方法中访问该对象的属性时，最好使用this</p>
</blockquote>
</li>
</ul>
<h4 id="对象创建的几种方式"><a href="#对象创建的几种方式" class="headerlink" title="对象创建的几种方式"></a>对象创建的几种方式</h4><ul>
<li><p>构造函数模式-构造函数</p>
<blockquote>
<p>首字母大写</p>
<p>this指向实例化的对象</p>
<p>new关键字来生成对象</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stu1</span>(<span class="params">name</span>)</span>&#123;<span class="built_in">this</span>.name=name;<span class="built_in">this</span>.show=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>.name)&#125;&#125;<span class="keyword">let</span> stu1=<span class="keyword">new</span> Stu1(<span class="string">&quot;nil&quot;</span>)stu1 <span class="comment">//Stu1 &#123;name: &#x27;nil&#x27;, show: ƒ&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>js内置函数-Object 构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu=<span class="keyword">new</span> <span class="built_in">Object</span>();<span class="comment">//Object 构造函数var stu2=&#123;&#125;//也使用了Object 构造函数</span></span><br></pre></td></tr></table></figure></li>
<li><p>原型模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stu3</span>(<span class="params"></span>)</span>&#123;Stu3.prototype.name=<span class="string">&quot;wang&quot;</span>;Stu3.prototype.show=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>.name)&#125;&#125;<span class="keyword">let</span> stu31=<span class="keyword">new</span> Stu3()stu31.name  <span class="comment">//&#x27;wang&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>工厂函数</p>
<blockquote>
<p>工厂函数：内建函数都是类对象，在实际调用时创建了一个对象</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stu</span>(<span class="params">name</span>)</span>&#123;<span class="keyword">return</span>&#123;name,<span class="function"><span class="title">show</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>.name)&#125;&#125;&#125;<span class="keyword">let</span> li=stu(<span class="string">&quot;li&quot;</span>);li <span class="comment">//&#123;name: &#x27;li&#x27;, show: ƒ&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>严格模式</p>
<blockquote>
<p>严格模式下，this值是undefined</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span><span class="function"><span class="keyword">function</span> <span class="title">Stu2</span>(<span class="params">name</span>)</span>&#123;<span class="built_in">this</span>.name=name;<span class="built_in">this</span>.show=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>.name)&#125;&#125;Stu2(<span class="string">&quot;a&quot;</span>) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-4-原型与继承"><a href="#2-3-4-原型与继承" class="headerlink" title="2.3.4 原型与继承"></a>2.3.4 原型与继承</h3><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><blockquote>
<p>所有引用类型（函数，数组，对象）都拥有_ proto _ 属性（隐式原型）</p>
<p>所有函数拥有prototype属性（显式原型）（仅限函数）</p>
<p>实例化对象的隐式原型指向它构造函数的显式原型：实例对象1._ proto_===构造函数.prototype</p>
</blockquote>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>原型链：当我们访问一个对象属性时，首先在这个对象内部查找，如果找不到会沿着_proto _一直找下去，这就形成了实例与原型的链条。</p>
<p>原型链中的指向问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;<span class="keyword">var</span> p1=<span class="keyword">new</span> Person();<span class="keyword">var</span> p2=<span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>1、实例对象中的_proto _指向构造函数的prototype</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.__proto__===Person.prototype <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>2、构造函数的prototype中的constructor指向构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.constructor <span class="comment">//ƒ Person()&#123;&#125;Person.prototype.constructor===Person //true</span></span><br></pre></td></tr></table></figure>

<p>3、原型对象中的_proto _是指向Object的prototype</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.__proto__===<span class="built_in">Object</span>.prototype <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>原型链终点就是Object.prototype，null表示没有对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bject.prototype.__proto__  <span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<p>在构造函数中经常会利用原型链：实现数据共享。原型链一个好处：<strong>数据共享，节省内存空间</strong></p>
<ul>
<li><p>setProrotypeOf(a,b) 将b设置成a的原型对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b=&#123;<span class="attr">name</span>:<span class="string">&quot;hhhh&quot;</span>&#125;<span class="built_in">Object</span>.setPrototypeOf(p1,b) <span class="comment">//Person &#123;&#125;p1.__proto__===b //true</span></span><br></pre></td></tr></table></figure></li>
<li><p>getPrototypeOf()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(p1) <span class="comment">//&#123;name: &#x27;hhhh&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h5 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h5><ul>
<li><p>核心：将父类的实例作为子类原型</p>
<ul>
<li><p>优点：</p>
<ol>
<li>简单易实现，子类可以访问父类的属性和方法</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>不能向父类构造函数传参</li>
<li>来自原型对象的所有属性被所有实例共享</li>
<li>无法实现多继承</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father1</span>(<span class="params">age</span>) </span>&#123;<span class="comment">//父类构造函数            this.age=age || 18;            this.habit=[1,2,3]        &#125;        Father1.prototype.say=  function()&#123;            console.log(&quot;年龄&quot;+this.age)        &#125;      	function Son1(name) &#123;//子类构造函数        this.name=name;        &#125;        Son1.prototype=new Father1(23); //将父类的实例作为子类的原型        console.log(Son1.prototype.constructor===Father1);//true        Son1.prototype.constructor=Son1;//注意：及时修正构造器的指向        console.log(Son1.prototype.constructor===Son1);//true        //问题1：实例化子类时无法给父类的构造函数传参        var boy1=new Son1(&quot;小李&quot;);        var boy2=new Son1(&quot;小张&quot;);        console.log(boy1.name,boy1.age,boy1.habit);//小李 23 (3) [1, 2, 3]        console.log(boy2.name,boy2.age,boy2.habit);//小张 23 (3) [1, 2, 3]        boy1.habit.push(&quot;hhhh&quot;);        //问题2：原型对象上的所有属性被所有实例共享，原型上的属性一旦修改对应的所有实例访问的属性也会更改        console.log(boy1.name,boy1.age,boy1.habit);//小李 23 (4) [1, 2, 3, &#x27;hhhh&#x27;]        console.log(boy2.name,boy2.age,boy2.habit);//小张 23 (4) [1, 2, 3, &#x27;hhhh&#x27;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="构造继承"><a href="#构造继承" class="headerlink" title="构造继承"></a>构造继承</h5><ul>
<li><p>核心：复制父类的实例属性给子类</p>
<ul>
<li><p>优点：</p>
<ol>
<li>解决了原型链继承中，子类实例共享父类属性的问题</li>
<li>创建子类实例时，可以向父类传参。</li>
<li>可以通过call多个父类对象实现多继承</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li><p>实例不是父类的实例只是子类的实例</p>
</li>
<li><p>只能继承父类的属性和方法，不能继承父类原型属性和方法</p>
</li>
<li><p>函数不能共享，影响性能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">age</span>) </span>&#123;    <span class="built_in">this</span>.age = age;    <span class="built_in">this</span>.home=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        <span class="built_in">console</span>.log(<span class="string">&quot;父亲&quot;</span>+age);    &#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>) </span>&#123;    <span class="built_in">this</span>.name=name;    Father.call(<span class="built_in">this</span>,age);&#125;<span class="keyword">var</span> boy1=<span class="keyword">new</span> Son(<span class="string">&quot;小李&quot;</span>,<span class="number">24</span>);<span class="keyword">var</span> boy2=<span class="keyword">new</span> Son(<span class="string">&quot;小zhang&quot;</span>,<span class="number">27</span>);<span class="built_in">console</span>.log(boy1.age);<span class="built_in">console</span>.log(boy2.age);boy1.home();<span class="comment">//父亲24boy2.home();//父亲27//函数不能重复使用，实例化过程会重新声明这个方法，两个方法是独立的，影响性能console.log(boy1.home==boy2.home);//false</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h5><ul>
<li><p>核心：通过调用父类构造函数，继承父类属性并保留传参的特点，然后将父类实例作为子类原型，实现函数复用</p>
<ul>
<li><p>优点：</p>
<ol>
<li>保留构造函数的优点：可以向父类构造函数传参</li>
<li>保留原型链特点实现方法复用：父类的方法定义在父类的原型对象上，实现方法复用</li>
<li>不共享父类的引用属性</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li><p>由于调用了2次构造函数，会存在多余的父类实例属性在子类原型中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">age</span>) </span>&#123;            <span class="built_in">this</span>.age=age;            <span class="built_in">this</span>.arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];            <span class="comment">//将需要复用的方法添加至原型对象中        &#125;        Father.prototype.say=function () &#123;            console.log(&quot;父类原型上的函数&quot;)        &#125;        function Son(name,age) &#123;            this.name=name;            Father.call(this,age);        &#125;        Son.prototype=new Father();        Son.prototype.constructor=Son;        var boy1=new Son(&quot;小张&quot;,24);        var boy2=new Son(&quot;小陈&quot;,25);        console.log(boy1.say===boy2.say);//true</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ul>
<p>当使用原型继承时，一定要注意子类对象的原型中的构造器指向（指向子类的构造函数）</p>
<h5 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h5><ul>
<li><p>核心：通过创建中间对象，将子类原型和父类原型隔开，避免父类原型与子类原型指向相同，当改变子类原型中的构造器指向时父类原型的构造器指向也发生改变</p>
<ul>
<li><p>优点：</p>
<ol>
<li><p>可以向父类函数传参</p>
</li>
<li><p>可以实现函数复用</p>
</li>
<li><p>只调用一次构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">age</span>) </span>&#123;            <span class="built_in">this</span>.age=age;            <span class="built_in">this</span>.arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];        &#125;<span class="comment">//将要复用的函数添加到父类函数的原型上        Father.prototype.aboutme=function () &#123;            console.log(&quot;父类函数&quot;)        &#125;        function Son(name,age) &#123;            this.name=name;            Father.call(this,age);        &#125;//通过创建中间对象，将子类原型和父类原型隔开        Son.prototype=Object.create(Father.prototype);        console.dir(Son.prototype);        console.dir(Father.prototype);        Son.prototype.constructor=Son;        var boy1=new Son(&quot;小李&quot;,27);        var boy2=new Son(&quot;小陈&quot;,22);        boy1.aboutme();</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="多态-未完"><a href="#多态-未完" class="headerlink" title="多态-未完"></a>多态-未完</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h3 id="2-3-5-RegExp-正则表达式"><a href="#2-3-5-RegExp-正则表达式" class="headerlink" title="2.3.5 RegExp 正则表达式"></a>2.3.5 RegExp 正则表达式</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/6513628.html">https://www.cnblogs.com/moqiutao/p/6513628.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/czf1987/p/14442981.html">https://www.cnblogs.com/czf1987/p/14442981.html</a></p>
<h4 id="常用的正则字符"><a href="#常用的正则字符" class="headerlink" title="常用的正则字符"></a>常用的正则字符</h4><h5 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h5><p><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_obj_regexp.asp">查看元字符</a></p>
<p><strong><code>\</code></strong> : 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’n’ 匹配一个换行符。序列 ‘&#39; 匹配 “” 而 “(“ 则匹配 “(“。</p>
<p>**<code>^</code>**：匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘n’ 或 ‘r’ 之后的位置。</p>
<p>**<code>$</code>**：匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘n’ 或 ‘r’ 之前的位置。</p>
<p>**<code>*</code>**：匹配前面的子表达式零次或多次。例如，zo <em>能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</p>
<p>**<code>+</code>**：匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</p>
<p>**<code>?</code>**：匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。</p>
<p>**<code>&#123;n&#125;</code>**：n 是一个非负整数。匹配字符连续出现了n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</p>
<p>**<code>&#123;n,&#125;</code>*<em>：n 是一个非负整数。匹配字符连续出现了n 次及以上。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o</em>‘。</p>
<p>**<code>&#123;n,m&#125;</code>**：m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</p>
<p>**<code>?</code>*<em>：当该字符紧跟在任何一个其他限制符 (</em>, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</p>
<p>11.**<code>·</code>**：匹配除 “\n”(换行符) 之外的任何单个字符。要匹配包括 ‘\n’(换行符) 在内的任何字符，请使用象 ‘[.\n]’ 的模式。</p>
<p>12.**<code>(pattern)</code>**：匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 0…0…9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)’。</p>
<p>13.**<code>(?:pattern)</code>**：匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式（进行的匹配是占据查询长度）。</p>
<p>14.**<code>(?=pattern)</code>**：正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95|98|NT|2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始（进行的匹配是不占查询长度的）。</p>
<p>15.**<code>(?!pattern)</code>**：负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95|98|NT|2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</p>
<p>16.**<code>x|y</code>**：匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</p>
<p>17.**<code>[xyz]</code>**：字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</p>
<p>18.**<code>[^xyz]</code>**：负值字符集合。匹配未包含的任意字符。例如， ‘1’ 可以匹配 “plain” 中的’p’。</p>
<p>19.**<code>[a-z]</code>**：字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</p>
<p>20.**<code>[^a-z]</code>**：负值字符范围。匹配任何不在指定范围内的任意字符。例如，’2’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</p>
<p>21.**<code>\b</code>**：匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘erb’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</p>
<p>22.**<code>\B</code>**：匹配非单词边界。’erB’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</p>
<p>23.**<code>\cx</code>**：匹配由 x 指明的控制字符。例如， cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</p>
<p>24.**<code>\d</code>**：匹配一个数字字符。等价于 [0-9]。</p>
<p>25.**<code>\D</code>**：匹配一个非数字字符。等价于 3。</p>
<p>26.**<code>\f</code>**：匹配一个换页符。等价于 x0c 和 cL。</p>
<p>27.**<code>\n</code>**：匹配一个换行符。等价于 x0a 和 cJ。</p>
<p>28.**<code>\r</code>**：匹配一个回车符。等价于 x0d 和 cM。</p>
<p>29.**<code>\s</code>**：匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ fnrtv]。</p>
<p>30.**<code>\S</code>**：匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</p>
<p>31.**<code>\t</code>**：匹配一个制表符。等价于 x09 和 cI。</p>
<p>32.**<code>\v</code>**：匹配一个垂直制表符。等价于 x0b 和 cK。</p>
<p>33.**<code>\w</code>**：匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。</p>
<p>34.**<code>\W</code>**：匹配任何非单词字符。等价于 ‘5’。</p>
<p>35.**<code>\xn</code>**：匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’x41’ 匹配 “A”。’x041’ 则等价于 ‘x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。</p>
<p>36.**<code>\num</code>**：匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)1’ 匹配两个连续的相同字符。</p>
<p>37.**<code>\n</code>**：标识一个八进制转义值或一个向后引用。如果 n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</p>
<p>38.**<code>\nm</code>**：标识一个八进制转义值或一个向后引用。如果 nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 nm 将匹配八进制转义值 nm。</p>
<p>39.**<code>\nml</code>**：如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</p>
<h4 id="正则表达式的定义方式"><a href="#正则表达式的定义方式" class="headerlink" title="正则表达式的定义方式"></a>正则表达式的定义方式</h4><h5 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h5><blockquote>
<p>var reg=/pattern/flags</p>
<p>pattern：简单/复杂的正则表达式</p>
<p>flags：用来标明该正则表达式的行为，有三个<strong>标志</strong></p>
<ul>
<li><p>g ：表示全局模式，会查找所有字符串，查到第一个匹配项就停止</p>
</li>
<li><p>i ：表示不区分大小写模式</p>
</li>
<li><p>m ：表示多行查找</p>
<p>以上，三个标志可组合使用</p>
</li>
</ul>
</blockquote>
<h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern=<span class="regexp">/\-/g</span>;pattern.test(<span class="string">&quot;hello--&quot;</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h5 id="使用RegExp构造函数"><a href="#使用RegExp构造函数" class="headerlink" title="使用RegExp构造函数"></a>使用RegExp构造函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/\d+\./</span>,<span class="string">&#x27;g&#x27;</span>);pattern.test(<span class="number">12.23</span>); <span class="comment">//true-----var pattern1=new RegExp(&quot;\d+\.&quot;,&#x27;g&#x27;)pattern1.test(12.23); //falsepattern1; // /d+./gpattern  // /\d+\./g----var pattern2=new RegExp(&quot;\\d+\\.&quot;,&#x27;g&#x27;);//双重转义pattern2.test(12.23);  //truepattern2; // /\d+\./g </span></span><br></pre></td></tr></table></figure>

<p>构造函数模式参数是字符串时要对字符进行双重转义，所有元字符必须双重转义</p>
<p><code>RegExp.$1</code> 是RegExp的一个属性指向的是正则表达式中第一个括号中匹配的字符串，以此类推</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(a)(ab)/g.exec(<span class="string">&#x27;aab&#x27;</span>);<span class="built_in">RegExp</span>.$1; <span class="comment">//&#x27;a&#x27;RegExp.$2; //&#x27;ab&#x27;RegExp.$3;//&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="RegExp对象中的方法"><a href="#RegExp对象中的方法" class="headerlink" title="RegExp对象中的方法"></a>RegExp对象中的方法</h4><ol>
<li><p>test()</p>
<p>检索字符串中指定的值，如果检索到即返回true 否则返回false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/\d+\./</span>,<span class="string">&#x27;g&#x27;</span>);pattern.test(<span class="number">12.23</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li><p>exec()</p>
<p>检索字符串中指定的值，匹配成功返回一个数组，否则返回null。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/l/g.exec(<span class="string">&quot;hello&quot;</span>); <span class="comment">//[&#x27;l&#x27;, index: 2, input: &#x27;hello&#x27;, groups: undefined]0: &quot;l&quot;groups: undefinedindex: 2input: &quot;hello&quot;length: 1lastIndex: (...)lastItem: (...)[[Prototype]]: Array(0)</span></span><br><span class="line">---</span><br><span class="line"><span class="keyword">var</span> res1=<span class="regexp">/(he)-(llo)/g</span>.exec(<span class="string">&quot;he-llo&quot;</span>);</span><br><span class="line">res1[<span class="number">2</span>]; <span class="comment">// &#x27;llo&#x27;</span></span><br><span class="line">res1[<span class="number">0</span>];  <span class="comment">//&#x27;he-llo&#x27;</span></span><br><span class="line">res1;  <span class="comment">//(3) [&#x27;he-llo&#x27;, &#x27;he&#x27;, &#x27;llo&#x27;, index: 0, input: &#x27;he-llo&#x27;, groups: undefined]</span></span><br></pre></td></tr></table></figure></li>
<li><p>compile()  返回值是一个正则表达式</p>
<ul>
<li><p>改变RegExp</p>
</li>
<li><p>添加删除第二个参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/hello/</span>;</span><br><span class="line">reg.exec(<span class="string">&quot;hellohhh&quot;</span>); <span class="comment">//[&#x27;hello&#x27;, index: 0, input: &#x27;hellohhh&#x27;, groups: undefined]</span></span><br><span class="line">reg.compile(<span class="string">&#x27;HELLO&#x27;</span>); <span class="comment">// /HELLO/</span></span><br><span class="line">reg.exec(<span class="string">&quot;hellohhh&quot;</span>); <span class="comment">//null</span></span><br><span class="line">reg.compile(<span class="string">&quot;HELLO&quot;</span>,<span class="string">&quot;i&quot;</span>) <span class="comment">// /HELLO/i</span></span><br><span class="line">reg.exec(<span class="string">&quot;hellohhh&quot;</span>);<span class="comment">//[&#x27;hello&#x27;, index: 0, input: &#x27;hellohhh&#x27;, groups: undefined]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>支持正则表达式的String对象方法有：search()、match()、replace()、split()</p>
</li>
</ol>
<h4 id="正则表达式实际应用"><a href="#正则表达式实际应用" class="headerlink" title="正则表达式实际应用"></a>正则表达式实际应用</h4>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JS/" rel="tag"># JS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/12/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="JS学习笔记">
                <i class="fa fa-chevron-left"></i> JS学习笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/logo.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
		<a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-JS"><span class="nav-number">1.</span> <span class="nav-text">2.3 JS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-js%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">2.3.1 js基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.1.</span> <span class="nav-text">关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%EF%BC%88number%EF%BC%89"><span class="nav-number">2.2.1.</span> <span class="nav-text">数值（number）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89"><span class="nav-number">2.2.2.</span> <span class="nav-text">字符串（String）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%EF%BC%88Boolean%EF%BC%89"><span class="nav-number">2.2.3.</span> <span class="nav-text">布尔类型（Boolean）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E5%80%BC%EF%BC%88null%EF%BC%89"><span class="nav-number">2.2.4.</span> <span class="nav-text">空值（null）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undefined%EF%BC%88%E6%9C%AA%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="nav-number">2.2.5.</span> <span class="nav-text">undefined（未定义）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Symbol-%E6%9C%AA%E5%AE%8C"><span class="nav-number">2.2.6.</span> <span class="nav-text">Symbol-未完</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BigInt-%E6%9C%AA%E5%AE%8C"><span class="nav-number">2.2.7.</span> <span class="nav-text">BigInt-未完</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.3.</span> <span class="nav-text">引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Array%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89"><span class="nav-number">2.3.1.</span> <span class="nav-text">Array（数组）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Set-%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.3.2.</span> <span class="nav-text">Set 对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Map%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.3.3.</span> <span class="nav-text">Map对象</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F-amp-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="nav-number">2.4.</span> <span class="nav-text">作用域&amp;作用域链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">2.5.</span> <span class="nav-text">操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.6.</span> <span class="nav-text">条件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#if%E2%80%A6else-%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.6.1.</span> <span class="nav-text">if…else 语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#swich-%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.6.2.</span> <span class="nav-text">swich 语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#break%EF%BC%8Ccontinue%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.6.3.</span> <span class="nav-text">break，continue关键字</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.7.</span> <span class="nav-text">循环</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#while-%E5%85%88%E5%88%A4%E6%96%AD%E5%90%8E%E6%89%A7%E8%A1%8C"><span class="nav-number">2.7.1.</span> <span class="nav-text">while 先判断后执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#do%E2%80%A6while-%E5%85%88%E6%89%A7%E8%A1%8C%E5%86%8D%E5%88%A4%E6%96%AD"><span class="nav-number">2.7.2.</span> <span class="nav-text">do…while 先执行再判断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.7.3.</span> <span class="nav-text">for循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#for-in%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.7.4.</span> <span class="nav-text">for-in循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#for-of%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.7.5.</span> <span class="nav-text">for-of循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#for%E2%80%A6in-%E5%92%8C-for%E2%80%A6of-%E6%AF%94%E8%BE%83"><span class="nav-number">2.7.6.</span> <span class="nav-text">for…in 和 for…of 比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">2.3.2 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">3.1.</span> <span class="nav-text">函数声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.</span> <span class="nav-text">函数表达式(匿名函数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Function-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">3.3.</span> <span class="nav-text">Function() 构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">3.4.</span> <span class="nav-text">匿名函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="nav-number">3.5.</span> <span class="nav-text">箭头函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">3.6.</span> <span class="nav-text">函数参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8-amp-this"><span class="nav-number">3.7.</span> <span class="nav-text">函数调用&amp;this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">3.8.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B2%99%E7%AE%B1-%E6%9C%AA%E5%AE%8C"><span class="nav-number">3.9.</span> <span class="nav-text">沙箱-未完</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.9.1.</span> <span class="nav-text"></span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.</span> <span class="nav-text">2.3.3 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="nav-number">4.2.</span> <span class="nav-text">对象常用操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.</span> <span class="nav-text">对象创建的几种方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">5.</span> <span class="nav-text">2.3.4 原型与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">原型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">5.2.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">5.3.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="nav-number">5.3.1.</span> <span class="nav-text">原型链继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E7%BB%A7%E6%89%BF"><span class="nav-number">5.3.2.</span> <span class="nav-text">构造继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="nav-number">5.3.3.</span> <span class="nav-text">组合继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="nav-number">5.3.4.</span> <span class="nav-text">寄生组合继承</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81-%E6%9C%AA%E5%AE%8C"><span class="nav-number">5.4.</span> <span class="nav-text">多态-未完</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#-1"><span class="nav-number">5.5.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-5-RegExp-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">2.3.5 RegExp 正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E5%AD%97%E7%AC%A6"><span class="nav-number">6.1.</span> <span class="nav-text">常用的正则字符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6"><span class="nav-number">6.1.1.</span> <span class="nav-text">元字符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="nav-number">6.2.</span> <span class="nav-text">正则表达式的定义方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RegExp%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.2.1.</span> <span class="nav-text">RegExp类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">6.2.2.</span> <span class="nav-text">字面量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8RegExp%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.3.</span> <span class="nav-text">使用RegExp构造函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RegExp%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">6.3.</span> <span class="nav-text">RegExp对象中的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="nav-number">6.4.</span> <span class="nav-text">正则表达式实际应用</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">moximoxi233</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  Website visitors:<span id="busuanzi_value_site_uv">3</span>
</span>
</div>



  <div class="powered-by"> 由moximoxi233负责维护</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link">hhh</a> </div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
